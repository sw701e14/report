As we have no specific target group, we would want our system to be as available as possible.
One way to do this is to implement it on a multitude of platforms (e.g. PC, Android devices, iOS devices).
However, this would require massive work, as all these platforms are different and would therefore require different implementations.
Additionally, it would not be very flexible, as new platforms and devices are frequently introduced on the market, requiring even further implementations.

Another way to make the system available, but without making it platform-dependent, would be to create a common web service that provides the most significant functionality of the system.

The following section will describe the possibilities when designing a web service, arguing why a RESTful web service is the correct choice for our system.
After the chosen architecture has been presented, the actual implementation will be presented.

\section{Choosing an architecture}
When designing a web service, there are two overall architectural styles; REST (Representational State Transfter) and RPC (Remote Procedural Call) \cite{restful_web_services}.
What we want to do is expose our resource state (part of our server state, e.g. bikes with their current locations).
As a RPC-style web service is by definition procedure-oriented, and what we want to do is expose resources, REST is the natural choice.

The remainder of this section will describe RESTful web services (specifically Resource-Oriented Architecture), based on \citet{restful_web_services}, \citet{fielding_dissertation}, and HTTP/1.1 Specification\cite{http_specification}.

\subsection{Representational State Transfer(REST)}
REST is an architectural style, which provides design criteria for network-based software architectures.
Web services adhering to these design criteria are referred to as RESTful web services.
These criteria were defined in \citet{fielding_dissertation}.
As REST is only an architectural style, making it possible to implement various correct architectures, we will be following one specific architecture implementation: Resource-Oriented Architecture (ROA) as described in \citet{restful_web_services}.

\subsection{Resource-Oriented Architecture(ROA)}\label{webservice:roa}
ROA is an architecture, upholding the REST design criteria.
This is done by organizing and accessing resources in a standardized manner, and by following and taking full advantage of the HTTP/1.1 specification.

In order to ensure that a ROA implementation will comply with the REST design criteria, it will have to adhere to the four concepts: \textit{resources, URIs, representing resources, linking resources}, along with the four properties: \textit{addressability, statelessness, connectedness, uniform interface} \cite[Chapter 4]{restful_web_services}.

\paragraph{Resources} are a subset of the resource state.
A single resource is an entity important enough to be a thing in itself.

Each resource should have at least one \textit{URI} (Unique Resource Identifier).
URIs ensure that each resource can be uniquely identified, directly handling the \textit{addressability} property.

\subparagraph{Representations} of resources depends on the desired use.
A representation of a specific resource is a collection of any useful information about that resource's state, defined by properties and sub-resources.

\paragraph{Connectedness and linking resources} are highly dependent on URIs.
As each resource is uniquely identified, any resource containing sub-resources or needing to refer to other resources, can do so by linking to its URI. 

\paragraph{Statelessness} is handled by providing, if any, state-relevant parameters on each request.
This makes the server independent of clients and previous requests, as it is up to each individual client to handle its own application state (not to be confused with the server's resource state) and providing it when needed.

\paragraph{Uniform interface} is where the HTTP/1.1 specifications come in.
By taking advantage of the HTTP methods GET, POST, PUT, DELETE, HEAD, and OPTIONS, every resource is handled the same way.
POST, GET, PUT, and DELETE correspond to the Create, Read, Update, Delete (CRUD) operations.
HEAD is for retrieving the resource's meta-data, without the actual representation.
OPTIONS is for seeing allowed methods for a given resource (additionally, by providing the Authorization header, actions can be restricted based on client permissions).

Any feedback needed to be given to clients from the server is handled through HTTP status codes (e.g. '200 OK', '404 Not Found').
