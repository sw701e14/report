\section{Generating Markov Chain}\label{sec:generatemarkov}
To generate the Markov chain $\mathcal{M}$ described in \cref{markov} we need a set of hotspots $H$ as found in \cref{} and a set of GPS data $GD$.\alexander{Insert reference to `Finding Hotspots' chapter}

A Markov chain is represented as a $n \times n$ matrix with the function $\tau_M(x, y) = \mathbb{P}(X_{n + 1} = y \mid X_n = x)$ as described in \cref{markov:math}.

To calculate the probability function $\mathbb{P}(X_{n + 1} = y \mid X_n = x)$ we generate the states by grouping the GPS data into their respective steps, of 5 minutes, and calculate which hotspot each GPS data belong to.

\begin{algorithm}[H]
\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
 
\Input{All GPS Data, $GD$, and all Hotspots, $H$.}
\Output{A Markov chain in form of a $n \times n$ matrix.}

 
$BikeData[\ ] \gets groupGpsDataByBike(GD)$
 
\ForEach{bike $\in BikeData$}
{
	$location \gets determineLocation(H, bike.StartLocation)$
}
 
\For{$s \gets$ FirstState $\KwTo$ LastState}
{
 	\ForEach{bike $\in BikeData$}
	{
 		$newLocation \gets determineLocation(H, bike.LocationState(s))$
 		
 		\If{$newLocation = location$}
 		{
 			$countMatrix[location, location]++$
 		}
 		\ElseIf{$newLocation \not= location$}
 		{
 			$countMatrix[location, newLocation]++$
 		}
 		
 		$location \gets newLocation$
 	}
}

\For{$i \gets 0$ $\KwTo$ $countMatrix.Size$}
{
	$rowSum \gets 0$
 	 
	\For{$j \gets 0$ $\KwTo$ $countMatrix.Size$}
	{
 		$rowSum \gets rowSum + countMatrix[i, j]$
 	}
 	\For{$j \gets 0$ $\KwTo$ $CountMatrix.Size$}
 	{
		$\mathcal{M}[i, j] \gets \frac{countMatrix[i, j]}{rowSum}$
	}
 }
 \caption{Pseudo Code of generating a Markov Chain.}
\end{algorithm}
