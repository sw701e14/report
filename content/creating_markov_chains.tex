\section{Generating Markov Chain}\label{sec:generatemarkov}
To generate the Markov chain $\mathcal{M}$ described in \cref{markov} we need a set of hotspots $H$ as found in \cref{} and a set of GPS data $GD$.\alexander{Insert reference to `Finding Hotspots' chapter}

The locations are grouped after their respective bike and the first location for each bike is found.
Then a matrix, representing the movement through the states, is generated by comparing the bikes locations in each state.
This matrix is then normalized to represent the distribution, thus being the Markov chain for the average bike.
The implementation can be seen in \cref{algo:markov}.


\begin{algorithm}[H]
\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
 
\Input{All GPS Data, $GD$, and all Hotspots, $H$.}
\Output{A Markov chain in form of a $n \times n$ matrix.}

$BikeData[\ ] \gets groupGpsDataByBike(GD)$
 
\ForEach{bike $\in BikeData$}
{
	$location \gets determineLocation(H, bike.StartLocation)$
}
 
\For{$s \gets$ FirstState $\KwTo$ LastState}
{
 	\ForEach{bike $\in BikeData$}
	{
 		$newLocation \gets determineLocation(H, bike.LocationState(s))$
 		
 		\If{$newLocation = location$}
 		{
 			$countMatrix[location, location]++$
 		}
 		\ElseIf{$newLocation \not= location$}
 		{
 			$countMatrix[location, newLocation]++$
 		}
 		
 		$location \gets newLocation$
 	}
}

\For{$i \gets 0$ $\KwTo$ $countMatrix.Size$}
{
	$rowSum \gets 0$
 	 
	\For{$j \gets 0$ $\KwTo$ $countMatrix.Size$}
	{
 		$rowSum \gets rowSum + countMatrix[i, j]$
 	}
 	\For{$j \gets 0$ $\KwTo$ $CountMatrix.Size$}
 	{
		$\mathcal{M}[i, j] \gets \frac{countMatrix[i, j]}{rowSum}$
	}
 }
 \caption{Pseudo Code of generating a Markov Chain.}
 \label{algo:markov}
\end{algorithm}
